#!/usr/bin/expect
# Obtains command output from Avaya Branch Gateway
# Returns JSON with gateway info, command outputs and RTP statistics
# MIT License
# version 0.1 Dec 2026
############################# Template Variables #############################

set lan_ip {lan_ip}
set user {user}
set passwd {passwd}
set rtp_stats {rtp_stats}
set prev_last_session_id {prev_last_session_id}
set prev_active_session_ids {prev_active_session_ids}
set commands {commands}
set debug {debug}

############################## Expect Variables ##############################

set options [list -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null]
set timeout 10
set prompt "\)# "
set last_session_id ""
set rc 0
array set commands_array {}
array set rtp_sessions_array {}
log_user 0

if {$debug} {
    set log_file "expect_debug_$lan_ip.log"
    if {[file exists $log_file]} {
        file delete $log_file
    }
    set dbg [open $log_file a]
    exp_internal -f $log_file 0
}

################################# Procedures #################################

proc json_escape {str} {
    set str [string map {
        "\\" "\\\\"
        "\"" "\\\""
        "\n" "\\n"
        "\r" "\\r"
        "\t" "\\t"
    } $str]
    return $str
}

proc to_json {} {
    global lan_ip gw_name gw_number last_seen last_session_id \
           commands_array rtp_sessions_array
    set json "{"
    append json "\"lan_ip\": \"[json_escape $lan_ip]\", "
    append json "\"gw_name\": \"[json_escape $gw_name]\", "
    append json "\"gw_number\": \"[json_escape $gw_number]\", "
    append json "\"last_seen\": \"[json_escape $last_seen]\", "
    append json "\"last_session_id\": \"[json_escape $last_session_id]\", "
    append json "\"commands\": {"
    set first 1
    foreach {key value} [array get commands_array] {
        if {!$first} {append json ", "}
        append json "\"[json_escape $key]\": \"[json_escape $value]\""
        set first 0
    }
    append json "}, \"rtp_sessions\": {"
    set first 1
    foreach {key value} [array get rtp_sessions_array] {
        if {!$first} {append json ", "}
        append json "\"[json_escape $key]\": \"[json_escape $value]\""
        set first 0
    }
    append json "}}"
    return $json
}

proc clean_output {output} {
    regsub -all "\r\n--type q to quit or space key to continue-- \r\[^ \]*K" \
           $output "" output
    regsub -all "Note that field.*" $output "" output
    regsub -all "Done!.*" $output "" output
    regsub -all "\r\n\[^ \]*\\)# " $output "" output
    return [string trimright $output]
}

proc cmd {command} {
    global prompt
    set output ""
    send "$command"
    expect {
        "*Processing another command please wait ...*" {
            error "ProcessingAnotherCommand"
        }
        "*do you want to continue (Y/N)?*" {
            set current_output $expect_out(buffer)
            append output $current_output
            send "Y\n"
            exp_continue
        }
        $prompt {
            set current_output $expect_out(buffer)
            append output $current_output
        }
        "*continue-- " {
            set current_output $expect_out(buffer)
            append output $current_output
            send "\n"
            exp_continue
        }
        "*to continue." {
            set current_output $expect_out(buffer)
            append output $current_output
            exp_continue
        }
        "*." {
            set current_output $expect_out(buffer)
            append output $current_output
            sleep 1
            exp_continue
        }
        timeout {
            error "ExpectTimeout"
        }
    }
    set result [clean_output $output]
    return [string trimleft $result $command]
}

# Centralized command execution with error handling and logging
proc exec_command {command {store_output 0}} {
    global debug dbg rc commands_array
    
    if {$debug} {
        puts $dbg "DEBUG: Execute '$command'"
        flush $dbg
    }
    
    set status [catch {set output [cmd "$command\n"]} errmsg]
    if {$status != 0} {
        set rc 253
        puts stderr "$errmsg while executing '$command'"
        if {$debug} {
            puts $dbg "ERROR: $errmsg while executing '$command'"
            flush $dbg
        }
        return ""
    }
    
    if {$store_output && $output ne ""} {
        set commands_array($command) $output
    }
    
    return $output
}

# Execute a list of commands, optionally stopping on first error
proc exec_commands {cmd_list {stop_on_error 0} {store_output 0}} {
    foreach command $cmd_list {
        
        set output [exec_command $command $store_output]
        if {$output eq "" && $stop_on_error} {
            return 1
        }
    }
    return 0
}

proc get_active_session_ids {} {
    set active_session_ids [list]
    set output [exec_command "show rtp-stat sessions active"]
    
    if {$output eq ""} {
        return {}
    }

    foreach line [split $output "\n"] {
        if {[regexp {^([0-9]+)\s+} $line _ id]} {
            lappend active_session_ids $id
        }
    }
    return $active_session_ids
}

proc get_last_session_id {} {
    set output [exec_command "show rtp-stat sessions last 1"]
    
    if {$output eq ""} {
        return ""
    }

    if {[regexp -line {^([0-9]+)\s+} $output _ id]} {
        return $id
    }
    return ""
}

proc get_new_session_ids {} {
    global prev_last_session_id last_session_id
    set new_session_ids [list]

    if {$prev_last_session_id eq ""} {
        return [get_active_session_ids]
    }

    if {$last_session_id eq ""} {
        return {}
    }

    scan $prev_last_session_id "%d" prev_id_decimal
    scan $last_session_id "%d" last_id_decimal
    set id [expr {$prev_id_decimal + 1}]
    while {$id <= $last_id_decimal} {
        lappend new_session_ids [format "%05d" $id]
        incr id 1
    }
    return $new_session_ids
}

proc capture_setup {output} {
    global debug dbg
    set setup_commands [list]

    if {$debug} {
        puts $dbg "DEBUG: Begin 'capture_setup' with output '$output'"
        flush $dbg
    }

    if {[string first "Buffer mode is non-cyclic" $output] == -1} {
        lappend setup_commands "capture buffer-mode non-cyclic"
    }
    if {[string first "from each frame: 4096" $output] == -1} {
        lappend setup_commands "capture max-frame-size 4096"
    }
    if {[string first "Capture list 501" $output] == -1} {
        lappend setup_commands \
            "no ip capture-list 501" \
            "ip capture-list 501" \
            "name udp" \
            "ip-rule 1" \
            "ip-protocol udp" \
            "composite-operation Capture" \
            "exit" \
            "ip-rule default" \
            "composite-operation No-Capture" \
            "exit" \
            "exit" \
            "capture filter-group 501"
    }

    if {[llength $setup_commands] == 0} {
        if {$debug} { puts $dbg "DEBUG: Execute: <none>"; flush $dbg }
        return 0
    }

    if {$debug} {
        puts $dbg "DEBUG: Execute '$setup_commands'"
        flush $dbg
    }
    return [exec_commands $setup_commands 1 0]
}

proc capture_start {} {
    global commands debug dbg
    
    if {$debug} {
        puts $dbg "DEBUG: Begin 'capture_start' with commands '$commands'"
        flush $dbg
    }

    # Remove "capture start" and "show capture" from commands list
    set commands [lsearch -all -inline -not -exact $commands "capture start"]
    set commands [lsearch -all -inline -not -exact $commands "show capture"]

    set output [exec_command "show capture"]

    if {$output eq ""} {
        return
    }

    set status [capture_setup $output]
    if {$status != 0} {
        return
    }

    lappend commands "clear capture-buffer"
    lappend commands "capture start"
    lappend commands "show capture"

    if {$debug} {
        puts $dbg "DEBUG: End 'capture_start' with commands '$commands'"
        flush $dbg
    }
}

proc merge_lists {list1 list2} {
    set combined [concat $list1 $list2]
    set result [lsort -unique $combined]
    return $result
}

#################################### Main ####################################

# Spawn SSH connection
spawn ssh -q {*}$options $user@$lan_ip

# Handle SSH login
expect {
    "Password: " {send "$passwd\n"}
    timeout {
        puts -nonewline stderr "ExpectTimeout"; exit 254
    }
    eof {
        puts -nonewline stderr "ExpectTimeout"; exit 254
    }
}
expect {
    "*Permission denied*" {
        puts -nonewline stderr "PermissionDenied"; exit 255
    }
    $prompt {}
}

# Extract gateway name and number from prompt
set gw_name ""; set gw_number ""
regexp {([^\s]+)-(\d+)[\(]} $expect_out(buffer) "" gw_name gw_number

# Set last_seen
set last_seen [exec date "+%Y-%m-%d,%H:%M:%S"]

# Start capture if requested
if {[lsearch -exact $commands "capture start"] != -1} {
    capture_start
}

if {[lsearch -glob $commands "copy capture-file*"] != -1} {
    lappend commands "show upload status 10"
}

# Execute all commands and store outputs
exec_commands $commands 0 1

# Collect RTP statistics if requested
if {$rtp_stats} {
    set last_session_id [get_last_session_id]
    set new_session_ids [get_new_session_ids]
    
    set merged_session_ids [
        merge_lists $new_session_ids $prev_active_session_ids
    ]

    if {$merged_session_ids ne {}} {
        set pattern {Start-Time:\s+(\S+),}
        foreach session_id $merged_session_ids {
            set output [exec_command "show rtp-stat detailed $session_id"]
            
            if {$output eq ""} {
                # Stop on first error
                break
            }
            
            set matches [regexp -inline $pattern $output]
            if {[llength $matches] > 1} {
                set start [lindex $matches 1]
                set global_id [format "%s,%s,%s" $start $gw_number $session_id]
                set rtp_sessions_array($global_id) $output
            }
        }
    }
}

# Output results in JSON format
puts [to_json]
exit $rc